---
layout: post
status: publish
published: true
title: 字节按位逆序
author:
  display_name: Simon Liu
  login: simon
  email: yuntao.liu@gmail.com
  url: http://log4think.com
author_login: simon
author_email: yuntao.liu@gmail.com
author_url: http://log4think.com
excerpt: "问题：给一个8位的字节，按位逆序。第一反应给了个简单的做法：\r\n<pre>unsigned short intreverse_bit(unsigned
  short int b)\r\n{\r\n    unsigned short int r = 0;\r\n    for (int i=0; i<8; i++)
  {\r\n        b >> = 1\r\n        r = (r << 1) | (b &amp; 1);\r\n    }\r\n    return
  r;\r\n}<&#47;pre>\r\n每次循环，r左移一位，b取最后一位填充到r的最后一位上，这个解答需要做8次循环，32次操作（左移一次，加法一次，右移一次，按位与一次）。很明显还有更好的做法。\r\n<pre>unsigned
  short int reverse_bit(unsigned short int b)\r\n{\r\n\tb = b << 4 + b >> 4;    &#47;&#47;
  &amp;11110000, 56781234\r\n\tb = (b &amp; 0x33) << 2 + (b &amp; 0xCC) >> 2;    &#47;&#47;
  &amp;11001100, 78563412\r\n\tb = (b &amp; 0x55) << 1 + (b &amp; 0xAA) >> 1;    &#47;&#47;
  &amp;10101010, 87654321\r\n\r\n\treturn b;\r\n}<&#47;pre>\r\n只需13次操作。\r\n\r\n"
wordpress_id: 407
wordpress_url: http://log4think.com/?p=407
date: '2011-01-09 03:57:35 +0800'
date_gmt: '2011-01-08 19:57:35 +0800'
categories:
- C&#47;C++
- Algorithm
tags: []
comments: []
---
<p>问题：给一个8位的字节，按位逆序。第一反应给了个简单的做法：</p>
<pre>unsigned short intreverse_bit(unsigned short int b)<br />
{<br />
    unsigned short int r = 0;<br />
    for (int i=0; i<8; i++) {<br />
        b >> = 1<br />
        r = (r << 1) | (b &amp; 1);<br />
    }<br />
    return r;<br />
}<&#47;pre><br />
每次循环，r左移一位，b取最后一位填充到r的最后一位上，这个解答需要做8次循环，32次操作（左移一次，加法一次，右移一次，按位与一次）。很明显还有更好的做法。</p>
<pre>unsigned short int reverse_bit(unsigned short int b)<br />
{<br />
	b = b << 4 + b >> 4;    &#47;&#47; &amp;11110000, 56781234<br />
	b = (b &amp; 0x33) << 2 + (b &amp; 0xCC) >> 2;    &#47;&#47; &amp;11001100, 78563412<br />
	b = (b &amp; 0x55) << 1 + (b &amp; 0xAA) >> 1;    &#47;&#47; &amp;10101010, 87654321</p>
<p>	return b;<br />
}<&#47;pre><br />
只需13次操作。</p>
<p><a id="more"></a><a id="more-407"></a>2011-01-18 更新：<br />
发现了更赞的做法，一个比一个奇技淫巧。</p>
<p>&nbsp;</p>
<h2>第一种解法，还是常用的一个一个的移位的做法。<&#47;h2><br />
把输入和输出当作两个队列，每次取一位，然后一个出队一个入队，代码更精简，支持多字节整数。</p>
<pre>unsigned int v;     &#47;&#47; 要反转的输入，这里的实现支持是多于一个字节的可实现位操作的无符号整数<br />
unsigned int r = v; &#47;&#47; r 将会是v的按位反转的结果，下面的for循环会先做右移操作，这里的赋值可以先取得v的最低有效位<br />
int s = sizeof(v) * CHAR_BIT - 1; &#47;&#47; 反转后需要做的额外的移位操作次数，CHAR_BIT为8，指一个字节包含的bit数</p>
<p>for (v >>= 1; v; v >>= 1)<br />
{<br />
  r <<= 1;<br />
  r |= v &amp; 1; &#47;&#47;取v的最低位的值，并置于r的最低位<br />
  s--;<br />
}<br />
r <<= s; &#47;&#47; v为0，s为v中剩余的高位为0的位数，填充到r的末尾<&#47;pre><br />
&nbsp;</p>
<h2>第二种解法，利用64位乘法和取模运算，三步操作解决<&#47;h2></p>
<pre>unsigned char b; &#47;&#47; 反转这个8位的字节</p>
<p>b = (b * 0x0202020202ULL &amp; 0x010884422010ULL) % 1023;<&#47;pre><br />
整个中间过程如下：</p>
<pre>           0000001000000010000000100000001000000010 -> 0x0202020202<br />
*                                          abcdefgh -> hgfe dcba<br />
---------------------------------------------------<br />
           000000h0000000h0000000h0000000h0000000h0<br />
          000000g0000000g0000000g0000000g0000000g0<br />
         000000f0000000f0000000f0000000f0000000f0<br />
        000000e0000000e0000000e0000000e0000000e0<br />
       000000d0000000d0000000d0000000d0000000d0<br />
      000000c0000000c0000000c0000000c0000000c0<br />
     000000b0000000b0000000b0000000b0000000b0<br />
    000000a0000000a0000000a0000000a0000000a0<br />
---------------------------------------------------<br />
    000000abcdefghabcdefghabcdefghabcdefghabcdefgh0<br />
&amp;   00000010000100010000100010000100010000000010000<br />
---------------------------------------------------<br />
    000000a0000f000b0000g000c0000h000d00000000e0000<br />
%   00000000000000000000000000000000000001111111111<br />
---------------------------------------------------<br />
    000000000000000000000000000000000000000hgfedcba<&#47;pre><br />
第一次乘法将字节复制成5份保存在一个64位整数里，第二次AND操作取出在正确位置（反转后的）上的位，每10位一组。这两次操作的结果是将每位放置到组中的正确位置上，注意下面每一位都在组中正确的相对位置上。</p>
<pre>000000a 0000f000b0 000g000c00 00h000d000 00000e0000<&#47;pre><br />
最后一步的取模操作，将之前的结果以每10位一组合并起来。其中利用到了取模的一个特点，当a<b时，a % b = a，而(a + b ) % p = (a % p + b % p) %p，当a + b < p的时候，就有(a + b ) % p = a % p + b % p。而这五组二进制的数的总和也是小于或等于1111111111的，因此最终取模的过程类似于如下操作</p>
<pre>    000000000a 0000000000 0000000000 0000000000 0000000000 % 1111111111 = 000000000a<br />
               0000f000b0 0000000000 0000000000 0000000000 % 1111111111 = 0000f000b0<br />
                          000g000c00 0000000000 0000000000 % 1111111111 = 000g000c00<br />
                                     00h000d000 0000000000 % 1111111111 = 00h000d000<br />
+                                               00000e0000 % 1111111111 = 00000e0000<br />
------------------------------------------------------------------------------------<br />
    000000000a 0000f000b0 000g000c00 00h000d000 00000e0000 % 1111111111 = 00hgfedcba<&#47;pre><br />
<strong>2011-01-20 补充：<&#47;strong><br />
之前的说明是我自己根据朴素的理解想明白的，但是hook同学知道了之后自己拿笔推了个公式出来，对于多项式\(P(x)\)来说，\(P(x)\mod (x-1) \equiv\)各项参数之和 ，也就是同余：<br />
\[ (a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+\cdots+a_1)\mod (x-1)=a_n+a_{n-1}+a_{n-2}+\cdots+a_1\]</p>
<p>hook的证明如下：<br />
设 y=x-1，代入P(x)有 \[(a_n(y+1)^n+a_{n-1}(y+1)^{n-1}+a_{n-2}(y+1)^{n-2}+\cdots+a_1)\mod y\]，根据二项式展开式\[ (a+b)^n=\sum_{i=0}^{n}C_{n}^{i}a^ib^{n-i} \]有 \[ (a+1)^n=\sum_{i=0}^{n}C_{n}^{i}a^i \]，展开得<br />
\[ (a_n\sum_{i=0}^{n}C_{n}^{i}y^i +  \cdots + a_1)\mod y = a_n *\sum_{i=0}^{n}C_{n}^{i}y^i\mod y+\cdots+a_1 \mod y \]，当\(i\ne0\)时\(a_n\sum_{i=0}^{n}C_{n}^{i}y^i\mod y=0\)，当\(i=0\)时\(a_n\sum_{i=0}^{n}C_{n}^{i}y^i\mod y=a_n\)，因此得证。</p>
<p>我的朴素证法：<br />
设 y = x - 1，代入P(x)有<br />
\[ (a_n(y+1)^n + a_{n-1}(y+1)^{n-1} +  \cdots + a_1)\mod y = a_n(y+1)^n\mod y + a_{n-1}(y+1)^{n-1}\mod y +  \cdots + a_1\mod y \]，<br />
根据模运算法则 \( a^b\mod p =  (a \mod p)^b\mod p\) 以及 \( (a * b)\mod p = ( (a\mod p) * (b\mod p) )\mod p \)，有<br />
\[ a_n(y+1)^n\mod y = (a_n\mod y)  ((y+1)\mod y )^n\mod p = a_n 1^n = a_n \]，<br />
因此有 \[ (a_n(y+1)^n + a_{n-1}(y+1)^{n-1} +  \cdots + a_1)\mod y = a_n + a_{n-1} + \cdots + a_1 \]</p>
<h2>第三种解法，仅用64乘法，4步解决<&#47;h2></p>
<pre>unsigned char b; &#47;&#47; reverse this byte</p>
<p>b = ((b * 0x80200802ULL) &amp; 0x0884422110ULL) * 0x0101010101ULL >> 32;<&#47;pre><br />
整个过程如下，乘法操作先将要反转的字节复制4份，然后AND操作将每2位分布到一个8位组中，最后乘法将结果叠加起来，中间的一个8位组正好包含完整的逆序结果，最后利用移位操作将这个完整的逆序8位组移至低8位。在将结果赋值回给b的时候，因为b是一个字节，因此近保留了有效的低8位，前面的无效数据全部被舍弃，正好是正确结果。</p>
<pre>                                                                                        abcd efgh (-> hgfe dcba)<br />
*                                                      1000 0000  0010 0000  0000 1000  0000 0010 (0x80200802)<br />
-------------------------------------------------------------------------------------------------<br />
                                            0abc defg  h00a bcde  fgh0 0abc  defg h00a  bcde fgh0<br />
&amp;                                           0000 1000  1000 0100  0100 0010  0010 0001  0001 0000 (0x0884422110)<br />
-------------------------------------------------------------------------------------------------<br />
                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
*                                           0000 0001  0000 0001  0000 0001  0000 0001  0000 0001 (0x0101010101)<br />
-------------------------------------------------------------------------------------------------<br />
                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
                                 0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
                      0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
           0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000<br />
-------------------------------------------------------------------------------------------------<br />
0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba  hgfe 0cba  0gfe 00ba  00fe 000a  000e 0000<br />
>> 32<br />
-------------------------------------------------------------------------------------------------<br />
                                            0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba<br />
&amp;                                                                                       1111 1111<br />
-------------------------------------------------------------------------------------------------<br />
                                                                                        hgfe dcba<&#47;pre><br />
&nbsp;</p>
<h2>第四种解法，仅用32位操作，7步解决<&#47;h2></p>
<pre>b = ((b * 0x0802LU &amp; 0x22110LU) | (b * 0x8020LU &amp; 0x88440LU)) * 0x10101LU >> 16;<&#47;pre><br />
中间过程如下：</p>
<pre>           0000100000000010 -> x0802<br />
*                  abcdefgh<br />
---------------------------<br />
           0000h000000000h0<br />
          0000g000000000g0<br />
         0000f000000000f0<br />
        0000e000000000e0<br />
       0000d000000000d0<br />
      0000c000000000c0<br />
     0000b000000000b0<br />
    0000a000000000a0<br />
---------------------------<br />
    0000abcdefgh00abcdefgh0  -> b * 0x0802LU<br />
&amp;   00000100010000100010000  -> 0x22110<br />
---------------------------<br />
    00000b000f0000a000e0000  -> (b * 0x0802LU &amp; 0x22110LU)<&#47;pre></p>
<pre>           1000000000100000 -> x8020<br />
*                  abcdefgh<br />
---------------------------<br />
           h000000000h00000<br />
          g000000000g00000<br />
         f000000000f00000<br />
        e000000000e00000<br />
       d000000000d00000<br />
      c000000000c00000<br />
     b000000000b00000<br />
    a000000000a00000<br />
---------------------------<br />
    abcdefgh00abcdefgh00000  -> b * 0x8020LU<br />
&amp;   00010001000010001000000  -> 0x0x88440<br />
---------------------------<br />
    000d000h0000c000g000000  -> (b * 0x8020LU &amp; 0x88440LU)<&#47;pre></p>
<pre>                        0000 00b0 00f0 000a 000e 0000  -> (b * 0x0802LU &amp; 0x22110LU)<br />
|                       0000 d000 h000 0c00 0g00 0000  -> (b * 0x8020LU &amp; 0x88440LU)<br />
-----------------------------------------------------<br />
                        0000 d0b0 h0f0 0c0a 0g0e 0000<br />
*                       0000 0001 0000 0001 0000 0001  -> 0x10101LU<br />
-----------------------------------------------------<br />
                        0000 d0b0 h0f0 0c0a 0g0e 0000<br />
              0000 d0b0 h0f0 0c0a 0g0e 0000<br />
    0000 d0b0 h0f0 0c0a 0g0e 0000<br />
-----------------------------------------------------<br />
    0000 d0b0 h0f0 dcba hgfe dcba hgfe 0c0a 0g0e 0000<br />
>> 16<br />
-----------------------------------------------------<br />
                        0000 d0b0 h0f0 dcba hgfe dcba<br />
&amp;                                           1111 1111<br />
-----------------------------------------------------<br />
                                            hgfe dcba<&#47;pre><br />
&nbsp;</p>
<p>这几个解法取自<a href="http:&#47;&#47;graphics.stanford.edu&#47;~seander&#47;bithacks.html" target="_blank">这里<&#47;a>，神一般的位操作，撰文留念。</p>
<p>&nbsp;</p>
